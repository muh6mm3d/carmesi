

# Carmesi Guide #

Carmesi is a framework for web applications that are based in the Model-View-Controller (MVC) pattern. The goal of Carmesi is to make easier the development of controller layer
by using a declarative approach and by removing verbose configuration files.

Carmesi is based in Servlet 3.0 API. Some simplifications for the user of Carmesi are possible thanks to features like web fragments and dynamic registration.

This guide is a major overview of Carmesi. It introduces all the functionality of the framework and, aditionally, offers some details of the internals of Carmesi to know how the features work.

## Features of Carmesi ##

  * No complicated configuration files. Carmesi needs a simple file but it can be autogenerated at compilation stage.
  * Performance. Only one instance of each controller class to serve multiple request at the same time.
  * Parameter injection from request parameters, scope attributes and cookies.
  * Lifecycle callbacks PostConstruct and PreDestroy supported.
  * CDI support.
  * JSON support.

## Requirements ##

  * JDK 6.
  * Container for Servlet 3.0.
  * For CDI support, your container must have a CDI provider ([Weld](http://seamframework.org/Weld)).
  * For JSON support, you have to include a proper JSON library (like [Jackson](http://jackson.codehaus.org/), [Gson](http://code.google.com/p/google-gson/)).

## Controllers ##

The controller is the core component in Carmesi. It encapsulates the communication with the view pages and the model classes. Carmesi offers common services to the
controller to made easier its development.

All the functionality below is available to controllers no matter its type.

### Types of controllers ###

There are two ways of defining a Carmesi controller class. For the first option, the controller class must implement the interface `Controller`:

```
public interface Controller {

    /**
     * Executes the controller.
     *
     * @param request The servlet request
     * @param response The servlet response
     * @throws Exception if there is a failure.
     */
    void execute(HttpServletRequest request, HttpServletResponse response) throws Exception;

}
```

This is an example of a controller implementing the interface:

```
public class AController implements Controller{

    @Override
    public void execute(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //controller logic
    }

}
```

The second option is using a POJO controller. POJO controller doesn't have to implement any special interface. All the configuration can be provided with annotations.
Carmesi can provide additional services to POJO controllers like parameter injection, processing of return values,
object conversion (String-Business objects). More detail on POJO controllers is given later.

Example:

```
/**
 *  Example of POJO controller.
 */
public class SimpleController {
    
    //Must have only one public method (excluding PostConstruct, PreDestroy, and injection methods)
    public void doOperation(){
        
    }

}
```

### Invocation of a controller ###

Controllers can be invocated in two ways: direct binding of the controller to an url or before another url is served.

A controller bound to a url is invoked when the user agent requests the url. The controller represents the url and it can delegate the responsability of response generation to the view.
To declare that a controller has direct binding use annotation URL and set the url as the value of the annotation.

Example:

```
import carmesi.Controller;
import carmesi.URL;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@URL("/index.html") //The controller is bound to this url.
public class URLController implements Controller{

    @Override
    public void execute(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //This controllers generates a simple response.
        response.getWriter().write("<html><body>Hello, world!</body></html>");
    }

}
```

The other type of invocation is when a controller is executed before another url is served. The Before-Controller is like a pre-step before serving a given url.
The annotation BeforeURL is used to define a controller with this kind of invocation.

Example

```
@BeforeURL("/books.jsp")
public class BeforeURLController {

    /* Auto request attribute*/
    public void doOperation(){
        //execute some logic before books.jsp is displayed
    }

}
```

It could be a matter of styles what type of invocation to use. In following example there are one view and two controllers with the same logic and
each one using a different invocation mechanism.

```
<!-- result.jsp -->
<html>
    <head>
        <title>Page</title>
    </head>
    <body>
        <h1>${value}</h1>
    </body>
</html>
```

```
/* Direct binding */
@URL("/index.html") //Controller is attached to this url. User request this.
@ForwardTo("/result.jsp") //The controller uses this view.
public class ResultRetriever {
    
    @RequestAttribute("value") //the return value is set to this attribute in the request
    public String getResult(){
        return "xyz";
    }

}
```

```
/* Before another url */
@BeforeURL("/index.jsp") //User requests the view but this controller is called before it. 
public class ResultRetriever2 {
    
    @RequestAttribute("value") //the return value is set to this attribute in the request
    public String getResult(){
        return "xyz";
    }

}
```

### Declare the response of a controller ###

It certain cases, the controller can generate the response by its own, but more common is to delegate this task to a view. The delegation is defined using either ForwardTo or RedirectTo annotation.
ForwardTo internally creates a dispatcher and later forwards to the url while redirect makes a call to `response.sendRedirect()`.

Both annotations receive a value that indicates the url to delegate the response generation. The url can be relative or absolute. If the url start with a slash / it means that is relative to the Servlet Context path
(this works with RedirectTo too and this behavior is different from response.sendRedirect so the values of RedirectTo and ForwardToo are consistent).

Example with ForwardTo:

```
@URL("/do")
@ForwardTo("/view.jsp")
public class ControllerWithForward {
    
    public void execute(){
        //logic
    }

}
```

Example with RedirectTo:

```
@URL("/do")
@RedirectTo("/view.jsp")
public class ControllerWithRedirect {
    
    public void execute(){
        //logic
    }

}
```

Note: ForwardTo and RedirectTo are valid with controllers annotated with URL. These annotations are ignored for controller with BeforeURL annotation.

### Allowed HTTP methods ###

If we need the controller only to be invoked with certains HTTP methods, the annotation AllowedHTTPMethods can be used to define what methods will be accepted.
If an empty array is specified as the value of this annotation, the controller will not be invoked no matter what the method is.

Example:

```
import carmesi.AllowedHttpMethods;
import carmesi.Controller;
import carmesi.HttpMethod;
import carmesi.URL;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@URL("/search")
@AllowedHttpMethods(HttpMethod.GET)
public class RestrictedController implements Controller{

    @Override
    public void execute(HttpServletRequest request, HttpServletResponse response) throws Exception {
        request.setAttribute("result", new String[]{});
    }

}
```

### CDI ###

CDI (Contexts and Dependency Injection) can be supported in containers with a CDI implementation available.
Carmesi uses CDI to inject fields and methods in the controller.

Example:

```
@URL("/index.html")
@ForwardTo("/view.jsp")
public class ControllerWithCDI {
    @Inject private A a;
    @EJB private MyEJB ejb;
    
    @PostConstruct
    public void init(){
        
    }
    
    @PreDestroy
    public void dispose(){
        
    }
    
    //controller method
    public void doOperation(){
        //use injected objects
    }

}
```

While injection on the controller is supported, Controllers are managed by Carmesi, so they aren't CDI beans. That means that you can not inject a controller
into another component.

The point of integration between Carmesi and CDI is the BeanManager class. When CDI is available, the BeanManager instance can be got via JNDI lookup. Carmesi tries
to do this lookup to find out if CDI can be used.

### Life cycle ###

Carmesi initialization module is an auto registered ServletContextListener that reads a resource with a list of controllers and converter classes. This resource is
generated by an annotation processor included in Carmesi. The name of the resource is META-INF/carmesi.list (If exists libraries in WEB-INF/lib each one can have its own file).

This is an example of the content of a configuration file:

```
carmesi.example.BeforeURLController
carmesi.example.ControllerWithCDI
carmesi.example.RestrictedController
carmesi.example.ResultRetriever
carmesi.example.ResultRetriever2
carmesi.example.URLController
```

Carmesi library has an annotation processor that can generate this configuration file from all the classes that are annotated with URL, BeforeURL and ConverterFor.
The Carmesi annotation processor is registered as a service so is called automatically in the compilation stage.

After reading the list of the classes, instances of the controller classes in the list are created (only one instance for each class is created). If CDI is available, is used to inject any specified fields.
After any injection, PostConstruct is called (PreDestroy callback method will be invoked when the servlet context is destroyed.).

Finally, controller classes defined are wrapped in a web component according to the type of invocation:

  * If the controller is annotated with URL, it's wrapped in a carmesi servlet.
  * If the controller is annotated with BeforeURL, it's wrapped in a carmesi filter.

Each web component is registered dynamically using the new functionality of the Servlet 3.0 API.

Converter classes are used to configure the POJO controllers (because only POJO controllers needs conversion for parameter injection).

## POJO controllers ##

A POJO controller is a class that doesn't need to implement any special interface. It must have a no-arg constructor
and have only one public method not annotated with PostConstruct, PreDestroy, Inject, Resource, WebServiceRef neither EJB. The method can have any name, throw any exception
and accept any number of paremeters (these parameters will be injected by Carmesi).

Example:

```
import carmesi.ForwardTo;
import carmesi.RequestAttribute;
import carmesi.RequestParameter;
import carmesi.URL;
import javax.annotation.PostConstruct;
import javax.inject.Inject;

@URL("/add")
@ForwardTo("/addView.jsp")
public class POJOController {
    
    @PostConstruct
    public void init(){
        
    }
    
    @Inject
    public void setBean(B b){
        
    }

    /* A POJO controller can return a value and annotation can be used to process it. */
    @RequestAttribute("result")
    /* The parameters are injected by the framework. Carmesi supports String-object conversion.*/
    public int add(@RequestParameter("a") int a, @RequestParameter("b") int b){
        return a+b;
    }
    
}
```

### Parameter injection ###

A POJO controller method can define a list of parameters. These parameters will be injected automatically when serving a request.

#### Injection of common types ####

For a parameter when is type if either HttpServletRequest, HttpServletResponse, ServletContext or HttpSession. The parameter doesn't need annotations to be injected.

```
@URL("/a")
@ForwardTo("/a.jsp")
public class ControllerA {
    
    public void execute(HttpServletRequest request, HttpSession session){
        
    }

}
```

#### Injection of context parameters. ####

If the parameter is annotated with ContextParameter, the value of the context init param with the given name is converted to the type of the
method parameter and injected. Object conversion is applied.

```
@URL("/b")
@ForwardTo("/b.jsp")
public class ControllerB {
    
    public void doOperation(@ContextParameter("number") int number){
        
    }

}
```

#### Injection of request parameters. ####

If the parameter is annotated with RequestParameter, the value of the request parameter with the given name
is converted to the type of the method parameter and injected. Object conversion is applied.

```
@URL("/c")
@ForwardTo("/c.jsp")
public class ControllerC {
    
    public void doOperation(@RequestParameter("age") int age){
        
    }

}
```

#### Injection of attributes. ####

If the parameter is annotated with ApplicationAttribute, SessionAttribute or RequestAttribute, the parameters is injected from an attribute with the given name in the respective scope.

```
@URL("/d")
@ForwardTo("/d.jsp")
public class ControllerD {
    
    public void doOperation(@SessionAttribute("mail") String mail){
        
    }

}
```

#### Injection of beans from request parameters. ####

If the parameter is annotated with RequestBean, bean introspection is used and a bean of the type of the method parameter is created and each of its properties is filled with
the value of the corresponding parameter if any. Object conversion is applied.

```
@URL("/e")
@ForwardTo("/e.jsp")
public class ControllerE {
    
    //The bean properties are filled from request parameters with the same name.
    // i.e. bean1.name = request.getParameter("name"), bean1.number = Integer.parseInt(request.getParameter("number"))
    public void doOperation(@RequestBean Bean1 bean1){
        
    }

}
```

#### Injection of cookies. ####

If the parameter is annotated with CookieValue, the value of the cookie with the given name is converted to the type of the method parameter and injected. Object conversion is applied.

```
@URL("/f")
@ForwardTo("/f.jsp")
public class ControllerF {
    
    public void doOperation(@CookieValue("css-theme") String theme){
        
    }

}
```

#### Array types ####

Carmesi detects if a parameter is array when injecting parameters from the request. Each value of the parameter
will correspond to an element after individual conversion is applied.

Example:

```
@URL("/g")
@ForwardTo("/g.jsp")
public class ControllerG {
    
    public void execute(@RequestParameter("numbers") int[] numbers){
        //logic
    }

}
```

### Conversion ###

Carmesi uses conversion of String to objects when injecting parameters to the method of the controller (for request parameters and cookie values).
Conversion from object to String is used for adding cookies to the response.

Automatic conversion is implemented for the primitive types and its wrappers: int, short, long, byte, float, double, char, boolean. Conversion is provided for BigDecimal and BigInteger too.

Custom convertion can be made by providing implementations of the interface Converter. A converter has methods to convert from String to object
and to convert object to String. To register a Converter user the annotation @ConverterFor with the target class as its value.

Example:

```
public class B {
    private String text;

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
    
}

@ConverterFor(B.class) //Registered as the converter for type B.
public class MyConverter implements Converter<B>{

    @Override
    public B convertToObject(String stringValue, TargetInfo info) throws ConverterException {
        B b=new B();
        b.setText(stringValue);
        return b;
    }

    @Override
    public String convertToString(B value, TargetInfo info) throws ConverterException {
        return value.getText();
    }

}
```

The TargetInfo class contains the annotations and the type of the target. This provides information to the conversion process.

Example for String to Object conversion:

```
@URL("/example")
@ForwardTo("/index.jsp")
public class ExampleController {
    
    public void execute(@DatePattern("dd/MM/yyyy") Date date){
        //When converting String to Date, the targetInfo will contain the annotation DatePattern so 
        //the converter knows the format of the date to parse the string.
    }

}
```

Example for Object to String conversion:
```
@URL("/setDate")
@ForwardTo("/index.jsp")
public class ControllerWithCookie {
    
    @CookieValue("initDate")
    @DatePattern("MM/dd/yyyy") //The value of the cookie will have this format
    public Date getDate(){
        return new Date();
    }

}
```

Properties in the bean can be annotated too to provide information for conversion when using RequestBean:

```
public class SimpleBean {
    @DatePattern("MM/dd/yyyy")
    private Date date;
    
    private String number;

    /* Getters and setter ... */
    
}
```

Note: An implementation of converter for String-Date is provided in Carmesi and is registered for Date.class so the API user doesn't have to register manually.

When the target type is not a primitive type and there's no converter registered, Carmesi searchs the target type for a static method called valueOf that receives a String.
By convention, method valueOf(String) is used to create instances of a given class from a String representation. When converting from object to String, String.valueOf(Object) is used.

### Processing the return value ###

The return value of a controller can be processed by Carmesi. The posible actions to apply to the value are presented below.

#### Setting an attribute ####

The return value can be set in an attribute using either RequestAttribute, SessionAttribute or ApplicationAttribute.

```
/* The return value is set in an attribute.*/
@URL("/random")
@ForwardTo("/result.jsp")
public class GetRandomNumber {
    
    @RequestAttribute("value") //The other available annotations for attributes are SessionAttribute and ApplicationAttribute.
    public int getNumber(){
        return new Random().nextInt();
    }

}
```

Carmesi has the functionality to automatically set request attribute if the name of the method is prefixed with get and the method is not annotated.
The name of the attribute will be the name of the method without the prefix get and the first character in lowercase.

Example:

```
@URL("/randomBoolean")
@ForwardTo("/view.jsp")
public class GetRandomBoolean {
    
    /* The method has the prefix get. It could receive any parameters.
     * The name of the request attribute will be *value*.
     */
    public boolean getValue(){
        return new Random().nextBoolean();
    }

}
```

If you want to disable this behavior, set the context param in the web.xml as it follows.

```
<context-param>
    <param-name>carmesi.requestAttribute.autoGeneration</param-name>
    <param-value>false</param-value>
</context-param>
```

#### Adding cookies to the response ####

A cookie with the return value can be added to the response.

```
@URL("/setBlueTheme")
@ForwardTo("/index.jsp")
public class SetCssTheme {

    //the return value is sent as a Cookie in the response.
    @CookieValue("cssTheme")
    public String setCssTheme(){
        return "blue-theme";
    }

}
```

The cookie maxAge, by default has a value of -1 so it will be deleted when the browser is closed. This value can be changed in web.xml (value is specified in seconds).

```
<context-param>
    <param-name>carmesi.cookie.maxAge</param-name>
    <param-value>10</param-value>
</context-param>
```

If the type of the return value is javax.servlet.http.Cookie, is added automatically to the response too.

```
@URL("/setBlackTheme")
@ForwardTo("/index.jsp")
public class SetCssTheme2 {
    
    //When the return value is a Cookie, is sent automatically in the response.
    public Cookie setCssTheme(){
        Cookie cookie=new Cookie("cssTheme", "black");
        cookie.setMaxAge(3600);
        return cookie;
    }

}
```

#### Sending JSON to the client ####

The JSON representation of the value can be sent to the client (in this case, the controller doesn't need a view).

```
/* Bean class */
public class B {
    private String text;

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
    
}

@URL("/result")
public class GetResult3 {
    
    @ToJSON
    public B getB(){
        return new B();
    }

}
```

#### JSON Serialization ####

As we've seen before. A return value of a controller could be sent as JSON to the client, if method is annotated with ToJSON.

Example:
```
@URL("/getUser")
public class GetUser {
    
    @ToJSON
    public User getUser(){
        User user=new User();
        user.setName("dummy");
        user.setMail("dummy@dummyserver.com");
        return user;
    }

}
```

Carmesi uses an implementation of JSONSerializer to convert an object to its JSON representation. There are two implementation provided of this interface: JacksonSerializer that uses the Jackson API
(http://jackson.codehaus.org/) and GsonSerializer (http://code.google.com/p/google-gson/). The respective API's are not included in Carmesi so you
have to download them manually if you want to use them.

The default serializer is JacksonSerializer but can be changed by setting the context parameter in the web.xml file:

```
<context-param>
    <param-name>carmesi.json.serializer</param-name>
    <param-value>carmesi.json.GsonSerializer</param-value>
</context-param>
```

You can provide your own implementation of JSONSerializer if you want to use some other API. You will have to set it as the Carmesi json serializer in the web.xml file as seen before.

Example:
```
public class MyJSONSerializer implements JSONSerializer{

    @Override
    public String serialize(Object object) {
        String json= ""; //do custom json serialization or call an external API.
        return json;
    }

}
```

```
<context-param>
    <param-name>carmesi.json.serializer</param-name>
    <param-value>mypackage.MyJSONSerializer</param-value>
</context-param>
```